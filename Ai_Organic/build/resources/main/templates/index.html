<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>YOLOv8 객체 탐지 애플리케이션</title>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 20px;
        }
        .upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            margin-bottom: 25px;
        }
        .result-container {
            position: relative; /* 캔버스가 겹칠 수 있도록 기준점(relative) 설정 */
            width: 100%; /* 컨테이너 너비 고정 */
            margin-top: 30px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background-color: #000;
        }
        #detection-image {
            /* 이미지가 컨테이너를 채우도록 함 */
            width: 100%;
            height: auto;
            display: block; /* 이미지 하단의 작은 여백 제거 */
        }
        #detection-canvas {
            /* 이미지를 완벽하게 덮도록 설정 */
            position: absolute;
            top: 0;
            left: 0;
            /* [중요] 캔버스의 *표시* 크기를 이미지와 동일하게 설정 (너비 100%)
               JS가 픽셀 크기를 설정할 것이므로, CSS는 크기만 맞춥니다.
            */
            width: 100%;
            height: 100%;
        }
        .result-info {
            margin-top: 20px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 8px;
            text-align: left;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>YOLOv11 기반 객체 탐지</h1>

    <!-- ... (form 등 다른 HTML 코드는 동일) ... -->
    <form method="POST" th:action="@{/api/v1/yolo/detect}" enctype="multipart/form-data" class="upload-area">
        <input type="file" name="image" accept="image/*" required>
        <button type="submit">탐지 시작</button>
    </form>

    <div th:if="${detectionResult}" class="result-container">
        <img id="detection-image" th:src="${uploadedImagePath}" alt="탐지 이미지">
        <canvas id="detection-canvas"></canvas>

        <div class="result-info">
            <h3>탐지된 객체 목록</h3>
            <p th:each="detection, iterStat : ${detectionResult.detections}">
                - 객체 [[${iterStat.index + 1}]]:
                <span th:text="${detection.className}"></span> (신뢰도: <span th:text="${#numbers.formatDecimal(detection.confidence, 1, 4)}"></span>)
            </p>
        </div>
    </div>
</div>

<script th:if="${detectionResult}" th:inline="javascript">
    /*<![CDATA[*/ // Thymeleaf 인라인 스크립트 시작

    const detectionResult = /*[[${detectionResult}]]*/ null;

    if (detectionResult && detectionResult.detections && detectionResult.detections.length > 0) {

        const imageElement = document.getElementById('detection-image');
        const canvas = document.getElementById('detection-canvas');
        const context = canvas ? canvas.getContext('2d') : null;

        if (!context) {
            console.error("Canvas 또는 Context를 찾을 수 없습니다.");
        }

        // [새로운 핵심 로직] 바운딩 박스를 그리는 함수
        function drawDetectionBoxes() {
            console.log("--- drawDetectionBoxes (v2) 함수 시작 ---");
            const image = imageElement;

            // 1. 원본 이미지의 실제 픽셀 크기 (예: 1920x1080)
            const naturalWidth = image.naturalWidth;
            const naturalHeight = image.naturalHeight;

            // 2. 캔버스의 *그림판(버퍼)* 크기를 원본 이미지 크기로 설정
            canvas.width = naturalWidth;
            canvas.height = naturalHeight;

            // 3. 캔버스의 *CSS(표시)* 크기를 화면에 보이는 이미지 크기로 설정
            //    (CSS에서 width:100%, height:100%로 설정했으므로 이 줄은 생략 가능하나,
            //     명시적으로 JS가 크기를 제어하도록 남겨둘 수 있습니다.)
            // canvas.style.width = image.clientWidth + 'px';
            // canvas.style.height = image.clientHeight + 'px';

            console.log(`캔버스 그림판 크기 (원본): W=${canvas.width}, H=${canvas.height}`);
            console.log(`캔버스 표시 크기 (화면): W=${image.clientWidth}, H=${image.clientHeight}`);

            // 4. (중요) 이전에 그린 박스 모두 제거 (1920x1080 캔버스 기준)
            context.clearRect(0, 0, canvas.width, canvas.height);

            // 5. 텍스트/선 굵기 설정 (1920x1080 기준이므로 더 굵어야 함)
            const lineWidth = Math.max(5, naturalWidth * 0.003); // 원본 너비의 0.3%
            const fontSize = Math.max(24, naturalHeight * 0.02); // 원본 높이의 2%
            context.lineWidth = lineWidth;
            context.font = `${fontSize}px Arial`;

            detectionResult.detections.forEach(detection => {
                // 원본 픽셀 좌표 (예: [273.09, ... 1620.63, ...])
                const box = detection.boxAbsolute;
                const className = detection.className;
                const confidence = detection.confidence;

                if (!box || box.length !== 4) return;

                // 6. [핵심] 아무런 스케일링(XScale) 계산 없이 원본 좌표 그대로 사용!
                const x = box[0];
                const y = box[1];
                const w = box[2] - box[0];
                const h = box[3] - box[1];

                console.log(`[${className}] 원본 좌표 그대로 그림: x=${x}, y=${y}, w=${w}, h=${h}`);

                context.strokeStyle = 'red';
                context.strokeRect(x, y, w, h);

                context.fillStyle = 'white';
                const label = `${className} (${(confidence * 100).toFixed(1)}%)`;
                const textMetrics = context.measureText(label);

                let textY = y - fontSize - 5;
                if (textY < 0) {
                    textY = y + fontSize + 5;
                }

                context.fillRect(x, textY - fontSize, textMetrics.width + (lineWidth*2), fontSize + 5);
                context.fillStyle = 'black';
                context.fillText(label, x + (lineWidth), textY);
            });
            console.log("바운딩 박스 그리기 완료");
        }

        // 이미지가 (데이터 로딩 + CSS 렌더링) 모두 완료된 후 그리기 실행
        // 'load' 이벤트는 'complete'보다 더 신뢰할 수 있습니다.
        imageElement.onload = () => {
            console.log("이미지 OnLoad 이벤트 발생. 그리기 시작.");
            drawDetectionBoxes();
        };

        // (예외 처리) 이미지가 너무 빨리 캐시에서 로드된 경우
        if (imageElement.complete && imageElement.naturalWidth > 0) {
            console.log("이미지가 이미 로드(캐시)됨. 그리기 시작.");
            // setTimeout을 0으로 주어 브라우저 렌더링 틱 다음으로 실행을 연기
            setTimeout(drawDetectionBoxes, 0);
        }

        // 창 크기가 바뀔 때마다 캔버스 크기와 박스 위치를 다시 계산
        window.addEventListener('resize', () => {
            console.log("창 크기 변경됨. 다시 그리기.");
            drawDetectionBoxes();
        });
    }

    /*]]>*/ // Thymeleaf 인라인 스크립트 종료
</script>
</body>
</html>

